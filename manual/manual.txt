<p>JORK is an ORM (Object-Relational Mapping) library for the CyclonePHP framework.
It is designed to provide fast, flexible and featureful mapping mechanism
between PHP object graphs and relational databases.</p>

@section jork-orm-intro Introduction to ORM

<p>The problem of object-relational mapping occurs when we try to build an application using an
   object-oriented programming language and using a relational database for data storage. The
   source of the problem is the theoretical difference between the data representation in object-
   oriented context and in RDBMS systems. In a nutshell OO systems consider any kind of data as a
   network or graph of connected object, and on the other hand the database handles the data in
   tables and represents connections using key columns. ORM systems are used to automatize the
   process of mapping objects to database records and vica-versa.
</p>

@subsection jork-orm-intro-problem The problem

<p>The base idea is to map an object to a row of a database relation. This task itself is simple, but
the theoretical mismatch between the data approach of object-oriented programming languages
and relational databases makes it complex, mainly because of the different representation of
connected entities.</p>

<h5>Terminology:</h5>

(terms used in the rest of the manual)
<dl>
<dt>entity class, model class:</dt>
    <dd>a class which' instances should be managed by the ORM library.
        In most cases these are business entities.</dd>
<dt>entity, model:</dt>
    <dd>an instance of an entity class.</dd>
</dl>
The "database", "database relation" and "database row" terms will also be used in the
further discussion of the topic.

<p>
In database tables the entities are stored in rows, every table has one or more columns which'
value is unique and not null (so-called primary keys), these are used to exactly identify an entity
in the storage. The connections between entities are represented using foreign keys. A foreign
key is on (or more) column of a database table (table A) which' value should be the same as the
value of a primary key in an other (or in special cases in the same) table (table B). In such case it
is interpreted as the foreign key value in a row in table A "refers to" a row in table B. Furthermore
table B also refers to table A, using the primary key of table B and the foreign key of table A the
connection between the two entities can be easily fetched from both sides. It means that the
connection between entities are always bi-directional in a relational database.
</p>

<p>The data representation in object-oriented languages differ basically in three things:
<ol>
<li>The entities represented by objects don't necessarily have one (or more) unique not-null
properties which can be used to exactly identify the entity. This is not needed in OO context since
the objects can be properly identified by their memory address and the memory address can be
referenced theoretically from any part of the application. Such physical address of the entities is
not accessible in relational databases, therefore it can't be used to identify the entities, primary
keys are used instead.</li>
<li>
The connections in a relational database are always bi-directional. In the case of object-
oriented languages if object A has a reference to object B then it doesn't necessarily mean that
object B also holds a reference to object A therefore the connections can easily be uni-directional.</li>
<li>
Foreign keys are also unneeded and unused in OO context since - as stated above - the
memory address of the objects is used to identify them via references (pointers). The entities hold
references (in their properties) to their components or (in the case of to-many relations) to
collections which store the components.</li>
</ol>

<em>Note: in point 1. we stated that the primary key property is not necessary for the in-memory
    identification of an entity, however for practical reasons such primary key-like properties are
    maintained for entities. For example during network communication this primary key is often
    used to identify an entity, and this primary key value is practically the same as the primary key
    value of the corresponding database row. Furthermore most ORM libraries require the presence
    of the primary key mapping property in the entity classes.
</em>
</p>

@section jork-orm-intro-oo Representing connections between entities in OO systems

<p>In this chapter we will discuss in more details how the representation of the connections between
   entities differ in OO systems and relational databases. This discussion will only cover the so-
   called standard, well-known connection representations, since in some programming languages
   and database systems very environment-specific connection representations can be implemented.
   In this chapter by “connection” associations are meant, and a short brief about mapping
   compositions will also be included. An object association is a relationship between two objects
   such that at least one of them can navigate to the other one. The connection is bi-directional if the
   navigation is also possible in the reverse order, otherwise it is unidirectional. Associations can be
   classified by their cardinality which defines how many objects can take part in the association on
   each side.
</p>

@subsection jork-orm-1-1 One-to-One (1:1) connections

In OO context we can say that A and B classes are in one-to-one connection if
<ul>
    <li>the instances of class A have a property with type class B.</li>
    <li>Optionally the instances of class B can have a property with type class A. In such case the
        connection is bi-directional.</li>
</ul>
Representing one-to-one connections in database systems:
<ul>
    <li>separate tables should be created for storing the entities of class A and class B (table_a
        and table_b).</li>
    <li>table_b should have a unique foreign key to table_a to map the connection</li>
</ul>

In cases when the one-to-one connection is a part-and-whole association (i.e. composition) the
foreign key in table_b should have a “not null” constraint. Practically in such case the primary
key of table_b can also be used as the foreign key to table_a. The foreign key references in most
cases (but not necessarily) the primary key of table_a.

@subsection jork-orm-1-n One-to-Many (1:N) connections

In OO context we can say that A and B classes are in one-to-many connection if
<ul>
    <li>the instances of class A have a property with a collection type which' items are instances
        of class B.</li>
    <li>Optionally the instances of class B can have a property which' values should be instances
        of class A. In such case the connection is bi-directional.</li>
</ul>

Representing one-to-many connections in database systems:
<ul>
    <li>separate tables should be created for storing the entities of class A and class B (table_a
        and table_b).</li>
    <li>table_b most have a foreign key to table_a. This foreign key in most cases references the
        primary key of table_a but it is not mandatory. The foreign key in table_a shouldn't be unique, but
        the referenced column(s) in table_a should be unique.</li>
</ul>

This is a widespread database representation of a one-to-many connection, though it introduces
further constraints on the data structure (in addition to the ones described above): no instances of
class B can occur multiple times in a collection of a given A instance. The object model described
above theoretically doesn't have such constraint, though in practice in most cases this restriction
on the object graph is implied by the underlying database. The entity collection implementations
of JORK take the advantage of this restriction and will be referred in the subsequent parts of the manual.

@subsection jork-orm-n-1 Many-to-One (N:1) connections

A many-to-one connection is the inverse of a one-to-many connection. In OO context we can say
that A and B classes are in many-to-one connection if
<ul>
    <li>the instances of class A have a property with a collection type which' items are instances of class
        B.</li>
    <li>no instances of class B may be referred by more than one instance of class A.</li>
    <li>Optionally the instances of class B may have a property with type class A.</li>
</ul>

Representing many-to-one connections in database systems can be done in the same way as one-
to-many connections, but in this case table_a should own the foreign table and it should reference
table_b.

@subsection jork-orm-n-m Many-to-Many (N:M) connections

In OO terminology we can say that class A and class B are many-to-many connection
<ul>
    <li>if the instances of class A have a property with a collection type which' items should be
        instances of class B.</li>
    <li>Optionally if the instances of class B have a property with a collection type which' items
        must be instances of class A and it is used to traverse the same connection then the
        connection is bi-directional.</li>
</ul>
Representing many-to-many connections in database systems can be done using in the following
way:
<ul>
    <li>separate tables should be created for class A and class B (table_a and table_b).</li>
    <li>a join table should be created which contains a separate foreign key both to table_a and table_b.
        The columns of these foreign keys should have a “not null” constraint. The foreign keys reference
        in most cases (but not necessarily) the primary key of table_a and table_b.</li>
</ul>


<p>The ORM libraries do this mapping process using a mapping schema defined by the developer
   (the user of the ORM library). The mapping schema definition can be done in XML, annotations,
   or any other markup. The mapping schema defines mapping between class hierarchies and
   database schema.</p>

@section jork-activerecord The Active Record design pattern

<p>From the aspect of handling entities run-time at the object-oriented side of the application there
   are two concepts which classify the ORM libraries. These concepts are tigthly related to two
   design patterns called active record and data mapper patterns. JORK takes the advantage of
   the Active Record design pattern which will be described in this chapter.</p>

In short an active record is an object that
<ol>
<li>wraps a row in a database table or view,</li>
<li>encapsulates the database access,</li>
<li>3.and adds domain logic on that data</li>
</ol>

<p>Many ORM solutions implement the objects (entities) at run-time at the OO side of the mapping
   as active record instances. They make the usage of these active records easier by providing an
   abstract base class for the entity classes which has some common methods for simple data
   operations like inserting/updating an entity, simple querying. The disadvantage of these
   implementation is that the entity classes must be extended from an abstract active record class,
   therefore the superclass of the entity classes is "reserved" by the used ORM library. In single-
   inheritance OO languages it might cause problems if the programmer wants to use an other
   technology too which reserves the superclass of the entity classes.</p>

<p>On the other hand a reasonable advantage of such active record implementation is that it properly
   encapsulates the entity data with its related operations, therefore it makes any additional DAO
   layer unnecessary. The abstract base active record class can implement the
   general, simple operations (methods) of the entity classes, and the concrete subclasses can add
   their required entity-specific methods to it.</p>

@section jork-mapping-schema Mapping schema

<p>In JORK the entity classes should extend the @c cyclone\jork\model\AbstractModel class and implement
its abstract static method @c cyclone\jork\model\AbstractModel::setup() which should return a
@c cyclone\jork\schema\ModelSchema instance. The mapping schema should be created programmatically
in the <code>setup()</code> method, where the mapping schema is built with chained setter method calls.
The schema will be loaded by the library when it is needed first time.</p>

<p>In the rest of the manual we will work with the following database schema:<br/>
@img img/db-schema.png <br/>

It is the data model of an imaginary forum application. It is really simple, but all connection types
have at least one instance in it, therefore it will be good enough for describing the way how to
define the mapping schema in JORK entities.
</p>

<p>Lets the Model_Post class, which will be mapped to the t_posts table: @code
<?php

use cyclone as cy;
use cyclone\JORK;
use cyclone\jork\model;
use cyclone\jork\schema\ModelSchema;

class Model_Post extends model\AbstractModel {


    public static function setup() {
        // creating the ModelSchema instance using its static factory method
        return ModelSchema::factory()
        // setting the name of the database connection where the underlying database table exists
        // it is an optional property, by default the 'default' connection is used. See the manual
        // of the DB library for more details.
            ->db_conn('jork_test')
        // setting the table name
            ->table('t_posts')
        // creating a primitive property which' name is 'id' and its PHP type is int
            ->primitive(JORK::primitive('id', 'int')
        // setting up the table column name where the 'id' property should be mapped to
        // it is an optional property, by default the property name is used as column name
                ->column('postId')
        // marking the 'id' property as the auto-generated primary key of the entity
                ->primary_key()
        // creating a new primitive - the property name and the database column name are the same
        )->primitive(JORK::primitive('name', 'string')
        // yet another primitive, the property name and the column name are different
        )->primitive(JORK::primitive('topic_fk', 'int')->column('topicFk')
        // same
        )->primitive(JORK::primitive('user_fk', 'int')->column('userFk')
        // creating a component. A Model_Post instance will have a property named 'topic'
        // and its type will be Model_Topic - an other entity.
        )->component(JORK::component('topic', 'Model_Topic')
        // the connection's cardinality is many-to-one
        // meaning that many posts can have the same topic, but only one topic
        // can belong to a post
                ->type(JORK::MANY_TO_ONE)
        // the join column for representing this connection between the Model_Post and Model_Topic entities
        // (or between the t_posts and t_topics tables) will be the 'topicFk' column. It means that
        // a column named 'topicFk' exists in the t_posts table and it is a foreign key referencing
        // the primary key of the t_topics table (which is actually the topicId column).
                ->join_column('topicFk')
        // creating a component. A Model_Post instance will have a property named 'author'
        // and its type is Model_User - an other entity.
        )->component(JORK::component('author', 'Model_User')
            // the mapping schema of this property is defined on the other side
            // i.e. the Model_User class will have a property named 'posts' and its definition will
            // contain the mapping schema for this connection
                ->mapped_by('posts')
        // embedded components will be discussed later
        )->embedded_component('modinfo', 'Model_ModInfo');
    }

}
@endcode

The comments in the above definition basically describe what is going on here. Some further notes:
<ol>
<li>Line 18: In most cases you won't need to set the @c cyclone\jork\schema\ModelSchema::$db_conn property,
since in most cases applications use only one database, and its connection is named 'default'. On
the other hand the <code>db_conn</code> property can be very useful for applications working with
multiple databases.</li>
<li>Line 27: the id property is marked as primary key, and also considered as a primary key being
automatically generated by the database; but the automatic primary key generation is only the default value.
If the primary key value is assigned manually, then you have to use <code>->primary_key(JORK::ASSIGN)</code>.</li>
<li>Line 29: the type in a primitive property definition should always be a PHP scalar type name, NOT an SQL type.
The following values are accepted: <code>bool</code>, <code>boolean</code>, <code>int</code>,
<code>integer</code>, <code>string</code>, <code>float</code>.</li>
<li>Line 45:the join column should not only exist in the database but it also has to be mapped
to a property of the entity. It means if the join column is 'topic_fk' then a primitive propery
of the entity should be mapped to the 'topic_fk' database column. Furhermore in this case the
'topicId' primary key is used in the other table for representing the connection, which is the
typical case for many-to-one connections. It is just the default value, you can change it using
the @c cyclone\jork\schema\ComponentSchema::inverse_join_column() .</li>
</ol>

As you can see above the <code>Model_Post</code> instances have a property named <code>topic</code> which is
a <code>Model_Topic</code> instance. The <code>Model_Topic</code> is also an entity class therefore
it also has a mapping schema. Lets see:
@code
<?php
use cyclone as cy;
use cyclone\jork\model;
use cyclone\jork\schema\ModelSchema;
use cyclone\JORK;

class Model_Topic extends model\AbstractModel {

    public static function setup() {
        // creating the schema instance and setting up the connection and table name
        return ModelSchema::factory()
            ->db_conn('jork_test')
            ->table('t_topics')
            // setting up the primary key property
            ->primitive(JORK::primitive('id', 'int')->column('topicId')
                    ->primary_key()
            // setting up an ordinary primitive property
            )->primitive(JORK::primitive('name', 'string')
            // creating a many-to-many component
            // it means that a Model_Topic instance will have a property named 'categories'
            // and its value will be a collection of Model_Category instances
            )->component(JORK::component('categories', 'Model_Category')
            // setting the cardinality of the connection (semantics described above)
                ->type(JORK::MANY_TO_MANY)
            // for representing the connection in the database, a join table will be used
            // the name of the join table will be 'categories_topics', with 2 columns:
            // the 'topicFk' column will be used as a join column referencing the primary key
            //      of the 't_topics' table
            // the 'categoryFk' column will be used as a join column referencing the primary key
            //      of the 't_categories' table
                ->join_table(JORK::join_table('categories_topics', 'topicFk', 'categoryFk'))
            // creating a component named 'posts'
            )->component(JORK::component('posts', 'Model_Post')
                // its mapping schema is defined on the other side - see the definition
                // of the 'topic' property in the Model_Post class above, no other property
                // has to be set here. In the Model_Post class it is defined as a many-to-one
                // component, which indicates that from the Model_Topic side its a one-to-many
                // component. As a consequence a Model_Topic instance will have a property named
                // 'posts' and its value will be a collection of Model_Post instances.
                ->mapped_by('topic')
                // The on_delete property defines what to do with the posts when a topic is deleted
                // In this case it means that the t_posts.topicFk value should be set to NULL to
                // maintain data integrity
                ->on_delete(JORK::SET_NULL)
            // natural ordering: see later
            )->natural_ordering('name')
            ->embedded_component('modinfo', 'Model_ModInfo');
    }

}
@endcode

<p>
Notes:
<ol>
<li>As you can read above for mapping many-to-many connections the primary keys of the connected entities
are used by default. You can override this default, but it is a bit more complex. You have to set the
additional properties of the @c cyclone\jork\schema\JoinTableSchema instance created using
the @c cyclone\JORK::join_table() call. An example:
@code
// ...
->join_table(JORK::join_table('categories_topics', 'topicFk', 'categoryFk')
    // the join_column means the join column on the side of the declaring class (Model_Topic)
    // in this case
    ->join_column('topicId')
    // the inverse_join_column means the join column on the other side (Model_Category class in
    // this case)
    ->inverse_join_column('categoryId')
)
// ...
@endcode
It worths noting again that the join columns should be mapped to a primitive property of the entity
classes. For example in this case the <code>id</code> property of <code>Model_Topic</code> is mapped
to the <code>topicId</code> join column, and on the other side the <code>id</code> property of
<code>Model_Category</code> is also mapped to the <code>categoryId</code> property.
</li>
<li>
    A more detailed explanation of the @c cyclone\jork\schema\ComponentSchema::$on_delete property:
    lets consider a case when you have a topic with id = 5 primary key, and 3 posts belong to it.
    The latter part means that 3 rows in the t_posts table have topicFk = 5 values. The topicFk
    is a foreign key referencing the t_topics.topicId column meaning that the topicFk values should
    be NULL or a value which also exists in the t_topics.topicId column.<br/>
    <br/>
    Let's see what happens if we delete our topic with id = 5. It means that in the t_posts
    table there are 3 rows with topicFk = 5, but the value 5 does not exist anymore in the t_topics
    table. In such case we can say that our database is in inconsistent state. Such inconsistent
    state may or may not be detected by the underlying database systems, but anyway it is something
    our application must avoid. Generally there are 2 ways for resolving this inconsistency:
    <ol>
        <li>setting foreign key values to NULL: before the row with id = 5 is deleted from the t_topics table
            we can run the following SQL statement: UPDATE t_posts SET topicFk = NULL where topicFk = 5;
            and thats all, the foreign key constraint on the t_posts table won't be violated
            when the row from the t_topics table is deleted. If you want JORK to perform such
            operation then create the component schema definition with
            @c cyclone\jork\schema\ComponentSchema::$on_delete = @c cyclone\JORK::SET_NULL and
            the library will perform the appropriate UPDATE statement before deleting the Model_Topic
            entity.</li>
        <li>cascade deletion: in this context by "cascade" we mean that if an entity is deleted
            then its components are deleted too. So if in the above definition it would be
            <code>-&gt;on_delete(JORK::CASCADE)</code> instead of <code>-&gt;on_delete(JORK::SET_NULL)</code>
            then the library would delete a topic instance's posts too alongside with the topic when
            the topic's <code>delete()</code> method is called.</li>
    </ol>
</li>
</ol>
</p>

<p>Now lets see the mapping schema <code>Model_Category</code> which is in many-to-many connection
with the <code>Model_Topic</code> entity as it is described above.
@code
<?php

use cyclone as cy;
use cyclone\jork\model;
use cyclone\jork\schema\ModelSchema;
use cyclone\JORK;


class Model_Category extends model\AbstractModel {


    public static function setup() {
        return ModelSchema::factory()
            ->db_conn('jork_test')
            ->table('t_categories')
            ->primitive(JORK::primitive('id', 'int')->column('categoryId')
                    ->primary_key()
                )->primitive(JORK::primitive('name', 'string')
                )->primitive(JORK::primitive('moderator_fk', 'int')->column('moderatorFk')
                )
            ->component(JORK::component('topics', 'Model_Topic')
                    ->type(JORK::MANY_TO_MANY)->mapped_by('categories')
        // a one-to-one connection example here. By default the primary keys
        // are used on both sides as join columns. You can override it using
        // join_column() on the local side and with inverse_join_column() on the other side.
                )->component(JORK::component('moderator', 'Model_User')
                    ->type(JORK::ONE_TO_ONE)->join_column('moderatorFk')
                )->embedded_component('modinfo', 'Model_ModInfo');
    }

}
@endcode

In this example you can see how to define the mapping schema for a one-to-one connection. It is
fairly straightforward, you have to set up the join columns for the connected entities.
</p>

<p>
Lets see something more interesting. As it has been mentioned previously in the introduction the
core idea of ORM is to map an entity class to a database relation. This concept can lead to some
unwanted constraints on the database schema design and entity class design since it requires
strict one-to-one mapping between the classes and the relations. JORK has some tools to resolve
this constraint. One of the options is to use so-called secondary tables which means that you can
store the properties of the same entity in more than one database tables - and in some cases it is
good to design your database this way.
</p>

<p>A typical use-case of such database schema design is when some of the properties of an entity
are rarely used and/or their values are <code>NULL</code> in some cases. In such case it is efficient
to store these properties in an other table because this way one row of the base relation of the
entity consumes less space in the memory (and in the storage too), therefore the DBMS can cache in
the RAM more rows. The secondary table and the base table are connected using foreign key join columns
so it is possible to join it into a query when these rarely used properties are needed.</p>

<p>To see an example of how to define an entity schema which works on secondary tables lets examine
the <code>Model_User</code> entity class:
@code
<?php

use cyclone as cy;
use cyclone\jork\model;
use cyclone\jork\schema\ModelSchema;
use cyclone\JORK;

class Model_User extends model\AbstractModel {


    public static function setup() {
        return ModelSchema::factory()
            ->db_conn('jork_test')
        // passing the name of the primary (base) table
            ->table('t_users')
        // setting up a secondary table
        // its name will be user_contact_info
        // in the t_users table the userId column will be used as the join column
        // in the user_contact_info table the userFk column will be used as the join column
            ->secondary_table(JORK::secondary_table(
                'user_contact_info', 'userId', 'userFk'
                ))
            ->primitive(JORK::primitive('id', 'int')->column('userId')
                    ->primary_key()
                )->primitive(JORK::primitive('name', 'string')
                )->primitive(JORK::primitive('password', 'string')
                )->primitive(JORK::primitive('created_at', 'string')->column('createdAt')
        // setting up the email primitive property
        // and specifying the user_contact_info for its owner table instead of the
        // t_users (primary) table which is used by default.
                )->primitive(JORK::primitive('email', 'string')->table('user_contact_info')
        // the phone_num property's column, the phoneNum column will also be in the
        // t_user_contact_info secondary table
                )->primitive(JORK::primitive('phone_num', 'string')
                    ->table('user_contact_info')->column('phoneNum')
                )->natural_ordering('name')
            ->component(JORK::component('posts', 'Model_Post')
                    ->type(JORK::ONE_TO_MANY)
                    ->join_column('userFk')
                    ->on_delete(JORK::SET_NULL)
                )->component(JORK::component('moderated_category', 'Model_Category')
                    ->mapped_by('moderator')
                    ->on_delete(JORK::SET_NULL)
                );
    }

} @endcode
</p>

<p>In this chapter we discussed how to define the mapping schema metadata between entity classes and
database relations. In the subsequent chapter we will go on and look at how to use these entities.

@section jork-query Object queries

<p>As it has been mentioned in the introduction JORK has an internal DSL for querying objects. It is
an "object-oriented" query language which lets you write queries operating on entities and entity
properties without the exact knowledge of the underlying database schema. This object query is
compiled into an SQL query by JORK and it will be executed. The result of the SQL query will be
"translated" to an object graph. In this chapter we will cover the syntax and semantics of the object
queries.</p>

<p>The query language can be used by calling the static factory methods of the @c cyclone\JORK class.
In examples below we will assume that the <code>cyclone\JORK</code> is imported (ie. imagine a
<code>use cyclone\JORK;</code> statement).

@subsection jork-query-from Basic queries

<p>A basic query for selecting an entity looks like this:
@code $query = JORK::from('Model_Topic'); @endcode
This statement created the query itself. The <code>$query</code> variable will be an
@c cyclone\jork\query\SelectQuery instance. You have to call its @c cyclone\jork\query\SelectQuery::exec()
method to execute it and get the query result. To sum up, you will write
@code $result = JORK::from('Model_Topic')->exec(); @endcode
in most cases. The <code>$result</code> variable will be a collection of <code>Model_Topic</code>
instances:
@code $result = JORK::from('Model_Topic')->exec();
foreach ($result as $topic) {
    echo "topic {$topic->id}: {$topic->name}" . PHP_EOL;
} @endcode
</p>

<p><em>Note: as you can see the in this example you can access the <code>id</code> and <code>name</code>
properties of the <code>Model_Topic</code> instances although we did not declare these as the
properties of the <code>Model_Topic</code> class. These properties are "simulated" by the base
active record class, @c cyclone\jork\model\AbstractModel 's <code>__get()</code> and
<code>__set()</code> magic methods (read more <a href="http://php.net/manual/en/language.oop5.magic.php">
here</a> if you are not familiar with PHP's magic methods yet).</em></p>

<p>In the above query we specified we want to select <code>Model_Topic</code> instances but we
didn't give any detailed information about what properties do we want to select. In such case
JORK will select all of the primitive properties but none of the components. So in this case the
<code>id</code> and <code>name</code> properties will be loaded but the <code>posts</code> and
<code>categories</code> won't be loaded.

<p>In the mapping schema examples above you can see that in the schema definition of
<code>Model_Topic</code> there is a <code>-&gt;natural_ordering('name')</code>call which
sets the @c cyclone\jork\schema\ModelSchema::$natural_ordering property. Such call means that if
an object query is executed on the given entity and no other ordering is defined in the object query
then the query result will be ordered by the natural ordering of the entity. To sum up the
@code JORK::from('Model_Topic') @endcode
object query will be translated to an SQL query like
@code SELECT id, name FROM t_topics ORDER BY t_topics.name @endcode

@subsection jork-query-with Loading components

<p>In our first example we did not define which components have to be loaded. JORK offers two ways
for specifying component loading, so let's see the first method: using a WITH clause:
@code $result = JORK::from('Model_Topic')->with('categories')->exec();
foreach ($result as $topic) {
    echo "topic {$topic->id}: {$topic->name} belongs to the following categories: " . PHP_EOL;
    foreach ($topic->categories as $category) {
        echo "\tcategory {$category->id}: {$category->name}" . PHP_EOL;
    }
} @endcode
The WITH clause of the query can be defined by the @c cyclone\jork\query\SelectQuery::with() method
which accepts variable-length argument list, so we could also write
@code  JORK::from('Model_Topic')->with('categories', 'posts')->exec(); @endcode
in the above example if we would need the posts too for rendering.</p>

<p>The WITH clause works recursively so it is very simple to select the components of a component
of the root entity:

@code // loading the the moderators of the categories of the topics...
$result = JORK::from('Model_Topic')->with('categories.moderator')->exec();
foreach ($result as $topic) {
    echo "topic {$topic->id}: {$topic->name} belongs to the following categories: " . PHP_EOL;
    foreach ($topic->categories as $category) {
        // ... and rendering the name of the moderator too
        echo "\tcategory {$category->id}: {$category->name} (moderated by {$category->moderator->name})" . PHP_EOL;
    }
} @endcode
Thats all. Such "recursive" property references like <code>'categories.moderator'</code> are called
property chains and they can be used at almost any part of the object query - therefore the term
<i>property chain</i> will be used in the rest of the manual.</p>

@subsection jork-query-where Where conditions

<p>The WHERE clauses in an object query can be used for filtering the query result just like
in SQL, so the semantics are indentical and in a lot of cases you will write WHERE conditions
with JORK just like you would do with the DB library.</p>

<p><em>Note: the further examples will use the @c cyclone\DB module so an <code>use cyclone\DB;</code>
   import statement will be assumed.</em></p>

<p>A very simple example:
@code // selecting the users registered after 2010.11.11
$users = JORK::from('Model_User')->where('created_at', '>', DB::esc('2010-11-11'))->exec();
@endcode
The <code>'2010-11-11'</code> string is a parameter and it will come from untrusted user
input in most cases - therefore you must escape the parameter using @c cyclone\DB::esc() .
If you don't wrap the parameter into a <code>DB::esc()</code> call then the <code>'2010-11-11'</code>
string will be considered as a property of the <code>Model_User</code> entity class - which does
not exist - therefore the query compilation process will throw an exception. To sum up the code will
rarely be SQL-injectable since if you forget about proper escaping then your query will fail when
first running it.</p>

<p>The parameters of an object query can not only be primitive values but entities too. Let's see
an example:
@code $topic = new Model_Topic;
$topic->id = 14;
$result = cy\JORK::from('Model_Post')->where('topic', '=', $topic)->exec(); @endcode
Ad you can see they query parameter is a <code>Model_Topic</code> instance. The semantics are
fairly obvious - we want to filter the posts by the topic they belong to. In the generated SQL
the <code>$topic</code> object will be replaced with its primary key (which is 14 in this case).
</p>

<p>In the above example we used a property on the left operand of the selection represented by
its string literal notation. It is also possible to use such property literals on both sides.
For example if you want to query the posts which are written by the moderator of one of the
categories where the post's topic belongs to, you can do it this way:
@code $result = JORK::from('Model_Post')->where('author', '=', 'topic.categories.moderator')->exec(); @endcode
Such object comparation expressions are compiled in a type-safe manner, so for example if you write
@code JORK::from('Model_Post')->where('author', '=', 'topic')->exec(); @endcode
then a @c cyclone\jork\Exception will be thrown with message <code>unable to check equality of class
'Model_User' with class 'Model_Topic'</code>.

@subsection jork-query-order-by-offset-limit Order by, offset, limit

<p>The ORDER BY, OFFSET and LIMIT clauses of the object query have the same semantics as
in SQL (to be exact the OFFSET and LIMIT clauses are not the part of the SQL standard but since
they exist in the SQL dialect of MySQL, Postgres and some other database systems too we don't cover
what OFFSET and LIMIT means).</p>

<p>Example:
@code $result = JORK::from('Model_User')->order_by('id')->offset(20)->limit(10)->exec(); @endcode
It will be approximately compiled to the following SQL:
@code SELECT userId, name FROM t_users ORDER BY userId OFFSET 20 LIMIT 10; @endcode
</p>

@subsection jork-query-select The SELECT clause

<p>In the examples we have covered so far every query had one entity class specified in its FROM
clause and the query didn't have SELECT clause. The query selected the primitive properties of
the entity and loaded some components defined by the WITH clause. The queries written this way will
satisfy your needs in a lot of cases, but it is also possible to construct much more complex queries
with JORK. In this chapter we will cover these options.</p>

<p>To get started lets look at an objec query with multiple root entities in the FROM clause:
@code $result = JORK::select('post', 'topic')->from('Model_Post post', 'Model_Topic topic')
    ->where('post.topic', '=', 'topic')->exec(); @endcode

This query selects every <code>Model_Post</code> instance and the <code>Model_Topic</code> instance
it belongs to. The main point is that: if you have multiple root entities then you have to specify
an alias name for it which you can use to reference the entity class in the other parts of the query.
In this case the alias of <code>Model_Post</code> was <code>post</code> and the alias of
<code>Model_Topic</code> was <code>topic</code>. These alias names were used in the SELECT clause.
</p>

<p>The alias name can be used not only to reference the root entity class but its properties too,
recursively. In other words the items of the SELECT clause can be property chains starting with the
alias of a root entitiy.</p>

<p>The previous example query can also be written in the following form (by taking the advantage
of recursive property chains):
@code $result = JORK::select('post', 'post.topic')->from('Model_Post post'); @endcode
</p>

<p>Let's go back to the original example and examine the query result:
@code $result = JORK::select('post', 'topic')->from('Model_Post post', 'Model_Topic topic')
    ->where('post.topic', '=', 'topic')->exec();
foreach ($result as $row) {
    echo "post {$row['post']->id} belongs to topic {$row['topic']->id} ({$tow['topic']->name})" . PHP_EOL;
}
@endcode
The rows of the query result will be associative arrays with the following keys: <code>'post'</code>
and <code>'topic'</code> - so the property chains specified in the SELECT clause of the query.
The <code>'post'</code> key will be the index of a <code>Model_Post</code> instance which'
primitive properties are loaded but none of the components, and the <code>'topic'</code> will
be the index of a <code>Model_Topic</code> instance loaded in the same way.</p>

<p>The property chains in the SELECT clause can be suffixed by an alias name which can be used for
2 purposes:
<ol>
<li>for referencing the property in the latter parts of the query</li>
<li>for specifying the array keys in the rows of the query result</li>
</ol>
Let's see an example:
@code $result = JORK::select('post p', 'topic t')->from('Model_Post post', 'Model_Topic topic')
          ->with('t.categories')
          ->where('p.topic', '=', 't')->exec();
foreach ($result as $row) {
    echo "post {$row['p']->id} belongs to topic {$row['t']->id} ({$tow['t']->name})" . PHP_EOL;
} @endcode
As you can see we aliased <code>'post'</code> with <code>'p'</code> and <code>'topic'</code> with
<code>'t'</code>. We used these aliases for:
<ul>
    <li>referencing the topic in the WITH clause to express that we want to load the <code>categories</code>
    property of the topic (see <code>'-&gt;with('t.categories')</code>).</li>
    <li>referencing the post and the topic in the WHERE clause (see <code>-&gt;where('p.topic', '=', 't')</code>)</li
    <li>for using the aliases as array keys while processing the query result (see <code>$row['p']-&gt;id</code> etc).</li>
</ul>
</p>

<p>
<em>In this chapter we discussed how to use property chains in the SELECT clause and how to use their aliases but we
still selected all primitive properties of the selected entity at the end of the property chain. In the next
chapter we will examine how to specify exactly the properties of the entity to gain total control on the SELECT
clause of the generated SQL.</em>
</p>

@subsection jork-query-projection Property projection

<p>Property projection is a method for defining the properties of an entity we want to select. Its a kind of extension
of the SELECT clause with a bit different purpose and more compacty, totally different syntax. Let's see an example:
@code $result = JORK::select('post.author{id,name}', 'post.topic.categories{id,moderator}')
    ->from('Model_Post post')->exec(); @endcode

In this example we used 2 property projections; these are the parts between the curly braces. Let's see what does it mean:
<ol>
    <li><code>post.author{id,name}</code> means that we want to select the author of the post but only load its <code>id</code>
        and <code>name</code> primitive properties but none of the other properties</li>
    <li><code>post.topic.categories{id,moderator}</code> means that we want to select the categories of the components
        but only load
        <ul>
            <li>one primitive property (the <code>id</code>)</li>
            <li>one component (the <code>moderator</code>)</li>
        </ul>
        but nothing else.
</ol>
</p>

<p>To sum up: with property projection you can specify which properties have to be loaded. If a
property chain in the SELECT clause ends with a property projection then only the specified
properties will be loaded and nothing else will be added automatically. Furthermore the properties
enumerated in the property projection can not only be primitive properties but components too. As
it has been mentioned at the beginning of the <i>Loading components</i> chapter JORK offers two
ways for defining component loading in a query - actually one of these is the WITH clause and
the other one is property projection.</p>

<p>
<em>
Note: in the previous paragraph we said "the specified properties will be loaded and nothing else
will be added automatically". Well it is not exactly true since the join column values will always
be selected regardless they are enumerated in the projection or not. Some classes in the framework
require the presence of these values in the active records.
</em>
</p>

<p><em>
Note 2: although it was not shown in the previous example in the property projection it is
possible to specify not only single properties but property chains too. For example
@code JORK::select('post.topic.categories{id,moderator.posts.topic}') @endcode
is also a valid property projection (but take care about the difference between the meaning
of commas (,) and dots (.) in the projection).
</em></p>

@subsection jork-query-expr Database expressions

<p>Database expressions are any expressions recognized by your DBMS. They can be arithmetic operations,
database function calls, user-defined stored function calls, aggregate function calls, case expressions,
whatever else the underlying DBMS is able to recognize. If an item in the SELECT clause is not
a property chain passed as a string but a @c cyclone\db\CustomExpression instance (typically
created using @c cyclone\DB::expr() then it will be considered by JORK as a database expression.</p>

<p>In almost all cases when you want to write a database expressions you will want to reference
some properties of root entities used in the query, and it comes with a problem since JORK will use
its own SQL aliases for identifying the tables and columns - so you can never know how to reference
the column you want to use. Furthermore - even if you "find out" the alias it is not a good practice
to use the column name alias in the object query since such code could occasionally break on a mapping
schema change. You simply should not use table and column names in your query but only entity
classes and properties.</p>

<p>To resolve this problem JORK has a simple method: in database expressions you can use property
chains between curly braces and JORK will replace these with the appropriate column name during
query compilation. For example if you want to list users with their email addresses in a single
column of the result you may do it this way:
@code $result = JORK::select(DB::expr("concat({user.name}, ' (', {user.email}, ')') as name_email"))
    ->from('Model_User user')->exec(); @endcode
Thats all. The <code>{user.name}</code> and <code>{user.email}</code> literals will be replaced
with the actual column names which hold the property values. In this example these will be
<code>t_users_0_name</code> and <code>user_contact_info_0_email</code> but its
implementation-specific and you don't have to know about it. The rows of the query result
will be associative arrays with one element, and the array key of this element will be
<code>name_email</code> (this is the part of the database expression after the last whitespace
occurence, thats why JORK will assume it to be the column name in the SQL query result and
will also use it in the object query result).</p>

<p>To sum up:
<ul>
<li>You have to wrap the database expressions into a \c cyclone\DB::expr() call</li>
<li>You have to reference properties using curly braces in the database expression</li>
</ul>
</p>

<p>Database expressions can be used not only in the SELECT clause but in the WHERE clause and
the ORDER BY clause too. For example if you want to select the users registered on this week
you can do it this way:
@code JORK::from('Model_User')
    ->where(DB::expr('WEEK( {created_at} )'), '=', DB::expr('WEEK( now() )'))->exec(); @endcode
</p>

@subsection jork-query-group-by GROUP BY clause

<p>After getting familiar with database expressions we may look at how to write GROUP BY clauses
with JORK. The only reason why it became the last chapter of the query language discussion is that
you need to know how to call aggregate functions to use GROUP BY therefore the explanation of
database expressions were introduced before.</p>

<p>So group by clauses have exactly the same semantics as in SQL. As an example let's see how to
select the user names and the number of posts written by them:
@code $result = JORK::select('name', DB::expr("count( {posts.id} )"))->from('Model_User')
    ->group_by('name'); @endcode
The semantics are straightforward, nothing else to talk about it.</p>

@section jork-model Models and model collections

<p>The topic of this chapter is the run-time in-memory representation of entities by JORK. In the
introduction we studied the active record design pattern; in this chapter we will deeply examine
the active record implementation ( @c cyclone\jork\model\AbstractModel ) of JORK.</p>

<p>The aim of the active record implementation is
<ul>
    <li>to provide simple operations for manipulating entities</li>
    <li>to maintain data integrity in its internal data storage. It primarily means foreign key
        value updates when new component values are assigned to the entity. We will see some
        examples for better understansing.</li>
</ul>
The entities are modeled not only by active records but by active record collections too. If an
entity has a to-many component property (for example <code>Model_Topic.posts</code> or
<code>Model_Category.topics</code> then JORK will use its own collection implementations
(subclasses of @c cyclone\jork\model\collection\AbstractCollection ) for the
run-time representation of this collection. The aim of these collection implementations is to
make it possible to keep the run-time object model and the persistent storage in sync. It is
also about properly updating foreign keys when it is needed.</p>

@subsection jork-model-fk Foreign key updates

<p>The JORK active records and collections update foreign key values when it is needed. Atfer
some time of working with JORK it will feel natural and you will understand intuitively but in
this chapter we will look at some examples to see what is meant by "updating when it is needed".</p>

<p> @code $post = new Model_Post;
$topic = new Model_Topic;
$topic->id = 10;
$post->topic = $topic;
echo $post->topic_fk; // prints 10 @endcode
We created a <code>Model_Topic</code> and a <code>Model_Post</code> instance, manually assigned
the primary key value of <code>$topic</code> then a component value assignment was made:
<code>$post->topic = $topic;</code>. When this assignment has been executed the active record
realized it has to maintain the foreign keys. It fetched the join column names from the mapping
schema and found that the <code>t_topics.topicId</code> column value - which is stored in the
<code>Model_Topic.id</code> property - should be assigned to the <code>t_posts.topicFk</code>
column which is stored in the <code>Model_Post.topic_fk</code> property. This foreign key update
is needed for the database representation of the post. Therefore internally it made the
assignment and in the last statement of the above example (<code>echo $post->topic_fk;</code>)
the updated value is available. This is what is meant by "maintain data integrity in its internal
data storage" etc.
</p>

<p>Some further examples (just to get used to it):
@code $post = new Model_Post;
$user = new Model_User;
$user->id = 6;
$post->author = $user;
echo $post->user_fk; // prints 6 @endcode

@code $category = new Model_Category;
$user = new Model_User;
$user->id = 3;
$user->moderated_category = $category;
echo $category->moderator_fk; //prints 3 @endcode </p>

<p>The collection implementations do quite similar job - they update foreign key values both
in the memory and the database. Example:
@code $user = new Model_User;
$user->id = 15;
$post = new Model_Post;
$user->posts->append($post);
echo $post->user_fk; // prints 15 @endcode </p>

@subsection jork-model-collection Collections as hashmaps

<p>An other reasonable feature of the collection implementations is that they are more like a
hashmap than a collection. A collection is a set of key-value pairs where the values are entity
instances and the keys are the primary keys of the entity instances. It practically means that
if you want to look up an entity in a collection then you can obtain it by directly referencing
it my its primary key instead of searching for it in a foreach loop. Example:
@code $topic = new Model_Topic;
$topic->id = 42;
$post = new Model_Post;
$post->id = 23;
$topic->posts->append($post);
var_dump($post == $topic->posts[23]); // it will be true @endcode
An other example: if you remember the <i>Loading components</i> chapter you could find an example
there which looked like this:
@code $result = JORK::from('Model_Topic')->with('categories')->exec();
foreach ($result as $topic) {
    echo "topic {$topic->id}: {$topic->name} belongs to the following categories: " . PHP_EOL;
    foreach ($topic->categories as $category) {
        echo "\tcategory {$category->id}: {$category->name}" . PHP_EOL;
    }
} @endcode
Since <code>$topic->categories</code> is an entity collection we could write it this way too:
@code $result = JORK::from('Model_Topic')->with('categories')->exec();
foreach ($result as $topic) {
    echo "topic {$topic->id}: {$topic->name} belongs to the following categories: " . PHP_EOL;
    // obtaining reference to the collection index with $cat_id
    foreach ($topic->categories as $cat_id => $category) {
        // and $cat_id will contain the primary key therefore we
        // don't have to write $category->id here, $cat_id does the same
        echo "\tcategory {$cat_id}: {$category->name}" . PHP_EOL;
    }
} @endcode <p>

<p>Deleting an entity from the collection can also be done simply by referencing its primary key
and unsetting it. Example:

@code $user = new Model_User;
$user->id = 15;
$post = new Model_Post;
$post->id = 12;
$user->posts->append($post);

// deleting by simply unsetting the primary key
unset($user->posts[12]);
var_dump(count($user->posts)); // it will be 0 @endcode
It is important to understand that such <code>unset()</code> call will only remove the
<code>$post</code> from the <code>$user->posts</code> collection but it won't delete the <code>$post</code>
itself. Furthermore it will only modify the collection and won't persist the changes to the
 database directly therefore you should call the @c cyclone\jork\model\collection\AbstractCollection::save()
 method to save the changes (i.e. <code>$user->posts->save();</code>.</p>

@subsection jork-model-typesafe Type safety

<p>JORK always does type safety checks for component assignments. For example
@code $user = new Model_User;
$user->moderated_category = new Model_Post; @endcode
This assignment will throw a @c cyclone\jork\Exception since the value of the
<code>Model_User.moderated_category</code> should be a <code>Model_Category</code> instance and
not a <code>Model_Post</code> instance. The collections are typesafe too so
@code $topic = new Model_Topic;
$user = new Model_User;
$user->posts->append($topic); @endcode
will also fail with an exception.</p>

<p>JORK can optionally also do forced typecasts on primitive values. This is done only if the
value of the <code>jork.force_type</code> configuration key is <code>TRUE</code> (therefore it
can be simply turned off if someone doesn't need it). But let's see what does it mean:
@code $user = new Model_User;
// assigning a string value...
$user->id = '145';
// ...but after the assignment it becomes an integer
echo gettype($user->id); // prints 'integer' @endcode
After the assignment the originally passed string value became an integer. This type casting
has been done because in the mapping schema the <code>id</code> property was defined with
<code>int</code> type.</p>

@section jork-lazyloading Lazy loading

@subsection jork-lazyloading-intro Introduction

<p>The properties of each object existing in a complete object graph can be accessed by reading the
according property of an object, regardless the property is a primitive value or an other object.
Good quality ORM systems are mostly tending to simulate this feature to let application
developers use the persisted object graph as an in-memory object graph, this way more
completely fulfilling the aim of the ORM system. If the application can treat the object graph
fully existent in the memory - which means treating all aggregated object properties of an object
loaded - then the underlying complexity of the persistence layer is abstracted away, this way
letting developerts to concentrate on the business logic. On the other hand from the viewpoint of
the persistence layer completely loading the persistent objects can't or shouldn't be done, since as
a consequence loading one object would mean loading all of its related object properties
(recursively), which can easily result in a lot of unwanted SQL joins, and querying a lot of
objects which might be needed later, but far not necessarily. If an object loading would come with
loading all of its related properties (recursively) then such behavior would result in serious
unneeded memory consumption and IO overhead, therefore it is not viable alternative. Lazy
loading is a mechanism which is intended to solve this problem basically by loading an object
property of an entity only when it is needed. The lazy loading process is always done by the
persistence layer transparently for the application.</p>

@subsection jork-lazyloading-problem The problem with the idea of lazy loading

<p>One of the most criticized features of ORM at all is the potential database overhead caused
by lazy loading. A lot of ORM systems run their lazy loading algorithm when an unloaded property
is referenced by the application. It practically means that if you need a component but you
forgot about loading it (with property projection or WITH clause in the case of JORK) then
the ORM won't notify you about this problem but will execute an SQL query to fetch the
property value. It is bad if it happens once and can be terrible if it happens in the body
of a foreach loop (or whatever else). What's more it is "magically" done by the ORM therefore
it is quite difficult to recognize the problem.</p>

@subsection jork-lazyloading-jork Lazy loadig with JORK

<p>JORK solves the problem in the following way: if you want to read a property via a property
access then no lazy-loading will be done if the property is not loaded; the returned value will
be <code>NULL</code>. But if you use the property name as a method name then the lazy loading
process will be executed (if the property is not loaded yet). To make it less cryptic let's see
an example:
@code
$result = JORK::from('Model_Post')->where('id', '=', DB::esc(1))->exec();
$post = $result[0];
// it will be NULL
var_dump( $post->author );
// it will do the lazy loading and the Model_User instance will be returned
var_dump( $post->author() ); @endcode
The problem is that we loaded the <code>$post</code> but didn't load its <code>author</code>
property which we want to use later. In the first property access we used <code>author</code>
as a property name - therefore no lazy loading has been made by JORK and we got <code>NULL</code>.
In the second property access we used <code>author()</code> as a method name and in this form
JORK executed its lazy loading process and fetched the author of the post.</p>

<p>By this simple differentiation you can simply avoid unneeded lazy loadings by using
property names in as many cases as possible - but if something seems to be really complicated
or when you fetch the data you simply don't know yet what components will you need then the
lazy loading is still available by using the property name as a method name. It is a good practice
to not to rely on lazy loading and access properties by property names - but in some rare cases
the lazy loading (available by the method-name format) can be extremely useful.</p>